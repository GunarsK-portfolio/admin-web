name: E2E Tests

on:
  pull_request:
    branches: [main, develop]
  workflow_dispatch: # Allow manual trigger

env:
  PYTHON_VERSION: '3.12'
  # Service URLs - single source of truth
  # Use direct container ports (bypass Traefik) to avoid HTTPS redirect issues in CI
  AUTH_SERVICE_URL: http://localhost:8084
  ADMIN_API_URL: http://localhost:8083
  PUBLIC_API_URL: http://localhost:8082
  FILES_API_URL: http://localhost:8085
  ADMIN_WEB_URL: http://localhost:8081
  PUBLIC_WEB_URL: http://localhost:8080

jobs:
  e2e:
    name: E2E Tests
    runs-on: ubuntu-latest
    timeout-minutes: 30

    steps:
      - name: Checkout admin-web
        uses: actions/checkout@v6
        with:
          path: admin-web

      - name: Checkout infrastructure
        uses: actions/checkout@v6
        with:
          repository: ${{ github.repository_owner }}/infrastructure
          path: infrastructure
          token: ${{ secrets.GITHUB_TOKEN }}

      - name: Checkout e2e-tests
        uses: actions/checkout@v6
        with:
          repository: ${{ github.repository_owner }}/e2e-tests
          path: e2e-tests
          token: ${{ secrets.GITHUB_TOKEN }}

      - name: Checkout backend services
        uses: actions/checkout@v6
        with:
          repository: ${{ github.repository_owner }}/auth-service
          path: auth-service
          token: ${{ secrets.GITHUB_TOKEN }}

      - name: Checkout admin-api
        uses: actions/checkout@v6
        with:
          repository: ${{ github.repository_owner }}/admin-api
          path: admin-api
          token: ${{ secrets.GITHUB_TOKEN }}

      - name: Checkout files-api
        uses: actions/checkout@v6
        with:
          repository: ${{ github.repository_owner }}/files-api
          path: files-api
          token: ${{ secrets.GITHUB_TOKEN }}

      - name: Checkout public-api
        uses: actions/checkout@v6
        with:
          repository: ${{ github.repository_owner }}/public-api
          path: public-api
          token: ${{ secrets.GITHUB_TOKEN }}

      - name: Checkout public-web
        uses: actions/checkout@v6
        with:
          repository: ${{ github.repository_owner }}/public-web
          path: public-web
          token: ${{ secrets.GITHUB_TOKEN }}

      - name: Checkout database
        uses: actions/checkout@v6
        with:
          repository: ${{ github.repository_owner }}/database
          path: database
          token: ${{ secrets.GITHUB_TOKEN }}

      - name: Checkout portfolio-common
        uses: actions/checkout@v6
        with:
          repository: ${{ github.repository_owner }}/portfolio-common
          path: portfolio-common
          token: ${{ secrets.GITHUB_TOKEN }}

      - name: Setup Python
        uses: actions/setup-python@v5
        with:
          python-version: ${{ env.PYTHON_VERSION }}
          cache: 'pip'
          cache-dependency-path: e2e-tests/requirements.txt

      - name: Install E2E dependencies
        working-directory: e2e-tests
        run: |
          python -m pip install --upgrade pip
          python -m pip install -r requirements.txt
          python -m playwright install --with-deps chromium

      - name: Create infrastructure .env
        working-directory: infrastructure
        run: |
          cp .env.example .env
          # Update CORS to allow direct container ports (bypassing Traefik)
          echo "ALLOWED_ORIGINS_ADMIN=https://localhost:8443,http://localhost:81,http://localhost:8081" >> .env
          echo "ALLOWED_ORIGINS_AUTH=https://localhost:8443,http://localhost:81,http://localhost:8081" >> .env
          echo "ALLOWED_ORIGINS_FILES=https://localhost:8443,https://localhost,http://localhost:81,http://localhost:80,http://localhost:8081,http://localhost:8080" >> .env
          echo "ALLOWED_ORIGINS_PUBLIC=https://localhost,http://localhost:80,http://localhost:8080" >> .env
          # Configure frontend to use direct container ports (bypass Traefik for CI)
          echo "VITE_ADMIN_API_URL=http://localhost:8083/api/v1" >> .env
          echo "VITE_ADMIN_AUTH_URL=http://localhost:8084/api/v1/auth" >> .env
          echo "VITE_ADMIN_FILES_API_URL=http://localhost:8085/api/v1" >> .env
          echo "VITE_PUBLIC_API_URL=http://localhost:8082/api/v1" >> .env

      - name: Start infrastructure
        working-directory: infrastructure
        run: |
          docker compose up -d --build
          echo "Waiting for services to start..."

      - name: Wait for services to be healthy
        run: |
          echo "Starting parallel health checks..."
          timeout 120 bash -c 'until docker exec postgres pg_isready -U postgres; do sleep 2; done' &
          timeout 120 bash -c 'until curl -sf ${{ env.AUTH_SERVICE_URL }}/health; do sleep 2; done' &
          timeout 120 bash -c 'until curl -sf ${{ env.ADMIN_API_URL }}/health; do sleep 2; done' &
          timeout 120 bash -c 'until curl -sf ${{ env.PUBLIC_API_URL }}/health; do sleep 2; done' &
          timeout 120 bash -c 'until curl -sf ${{ env.FILES_API_URL }}/health; do sleep 2; done' &
          timeout 120 bash -c 'until curl -sf ${{ env.ADMIN_WEB_URL }}/; do sleep 2; done' &
          timeout 120 bash -c 'until curl -sf ${{ env.PUBLIC_WEB_URL }}/; do sleep 2; done' &
          wait
          echo "All services are healthy!"

      - name: Debug - Check built-in auth URL and test login
        run: |
          echo "=== Infrastructure .env VITE settings ==="
          grep -E "^VITE_" infrastructure/.env || echo "No VITE vars found"
          echo ""
          echo "=== Infrastructure .env CORS settings ==="
          grep -E "ALLOWED_ORIGINS" infrastructure/.env || echo "No CORS vars found"
          echo ""
          echo "=== Auth service container ALLOWED_ORIGINS ==="
          docker exec auth-service printenv ALLOWED_ORIGINS || echo "ALLOWED_ORIGINS not set in container"
          echo ""
          echo "=== Checking auth URL in built frontend ==="
          docker exec admin-web sh -c "cat /usr/share/nginx/html/assets/*.js" 2>/dev/null | grep -oE 'https?://[^"'\'']*' | sort -u | head -20 || echo "No URLs found in JS"
          echo ""
          echo "=== Testing direct auth endpoint with curl ==="
          curl -s -X POST ${{ env.AUTH_SERVICE_URL }}/api/v1/auth/login \
            -H "Content-Type: application/json" \
            -H "Origin: http://localhost:8081" \
            -d '{"username":"${{ secrets.TEST_ADMIN_USERNAME }}","password":"${{ secrets.TEST_ADMIN_PASSWORD }}"}' \
            -w "\nHTTP Status: %{http_code}\n"
          echo ""
          echo "=== Testing CORS preflight ==="
          curl -s -X OPTIONS ${{ env.AUTH_SERVICE_URL }}/api/v1/auth/login \
            -H "Origin: http://localhost:8081" \
            -H "Access-Control-Request-Method: POST" \
            -H "Access-Control-Request-Headers: Content-Type" \
            -w "\nHTTP Status: %{http_code}\n" -D -

      - name: Create E2E .env
        working-directory: e2e-tests
        run: |
          echo "TEST_ADMIN_USERNAME=${{ secrets.TEST_ADMIN_USERNAME }}" > .env
          echo "TEST_ADMIN_PASSWORD=${{ secrets.TEST_ADMIN_PASSWORD }}" >> .env
          echo "TEST_ADMIN_WEB_URL=${{ env.ADMIN_WEB_URL }}" >> .env
          echo "TEST_ADMIN_API_URL=${{ env.ADMIN_API_URL }}" >> .env
          echo "TEST_AUTH_API_URL=${{ env.AUTH_SERVICE_URL }}" >> .env
          echo "TEST_PUBLIC_WEB_URL=${{ env.PUBLIC_WEB_URL }}" >> .env
          echo "TEST_PUBLIC_API_URL=${{ env.PUBLIC_API_URL }}" >> .env
          echo "TEST_HEADLESS=true" >> .env
          echo "TEST_TIMEOUT=300000" >> .env
          echo "TEST_BROWSER=chromium" >> .env

      - name: Debug - Test browser login with network capture
        working-directory: e2e-tests
        run: |
          python3 << 'EOF'
          from playwright.sync_api import sync_playwright
          import json

          with sync_playwright() as p:
              browser = p.chromium.launch(headless=True)
              context = browser.new_context()
              page = context.new_page()

              # Capture console messages
              console_messages = []
              page.on("console", lambda msg: console_messages.append(f"{msg.type}: {msg.text}"))

              # Capture network requests/responses
              requests = []
              def on_request(request):
                  requests.append(f">> {request.method} {request.url}")
              def on_response(response):
                  requests.append(f"<< {response.status} {response.url}")
              page.on("request", on_request)
              page.on("response", on_response)

              print("=== Loading login page ===")
              page.goto("${{ env.ADMIN_WEB_URL }}/login")
              page.wait_for_load_state("networkidle")
              page.wait_for_timeout(2000)

              print("\n=== Network requests during page load ===")
              for r in requests:
                  print(r)

              print("\n=== Console messages ===")
              for msg in console_messages:
                  print(msg)

              requests.clear()
              console_messages.clear()

              print("\n=== Filling login form ===")
              username_input = page.locator('input[type="text"]').first
              password_input = page.locator('input[type="password"]').first

              username_input.fill("${{ secrets.TEST_ADMIN_USERNAME }}")
              password_input.fill("${{ secrets.TEST_ADMIN_PASSWORD }}")
              page.wait_for_timeout(500)

              print("\n=== Clicking login button ===")
              login_btn = page.locator('button:has-text("Login")').first
              login_btn.click()
              page.wait_for_load_state("networkidle")
              page.wait_for_timeout(3000)

              print("\n=== Network requests during login ===")
              for r in requests:
                  print(r)

              print("\n=== Console messages after login ===")
              for msg in console_messages:
                  print(msg)

              print(f"\n=== Final URL: {page.url} ===")
              print(f"=== Login successful: {'dashboard' in page.url} ===")

              page.screenshot(path="/tmp/debug_login.png")
              print("\nScreenshot saved to /tmp/debug_login.png")

              browser.close()
          EOF

      - name: Run E2E tests
        working-directory: e2e-tests
        run: |
          python run_all_tests.py --no-confirm
        # continue-on-error allows artifact upload and log collection before failing
        continue-on-error: true
        id: e2e_tests

      - name: Upload test artifacts
        if: always()
        uses: actions/upload-artifact@v5
        with:
          name: e2e-test-results
          path: |
            e2e-tests/test-results/
            e2e-tests/**/*.png
            e2e-tests/**/*.mp4
          retention-days: 7

      - name: Show docker logs on failure
        if: steps.e2e_tests.outcome == 'failure'
        working-directory: infrastructure
        run: |
          echo "=== Container status ==="
          docker compose ps -a
          echo ""
          echo "=== admin-web logs ==="
          docker compose logs admin-web --tail=100
          echo ""
          echo "=== auth-service logs ==="
          docker compose logs auth-service --tail=50
          echo ""
          echo "=== admin-api logs ==="
          docker compose logs admin-api --tail=50
          echo ""
          echo "=== files-api logs ==="
          docker compose logs files-api --tail=50

      - name: Stop infrastructure
        if: always()
        working-directory: infrastructure
        run: docker compose down -v

      - name: Check E2E test result
        if: steps.e2e_tests.outcome == 'failure'
        run: exit 1
